import logging
import re
import sys
from io import TextIOWrapper
from typing import Any, TextIO

from .key_seqv import KeySeqv
from .regex_groups import Groups, KEY_SEQV_REGEX, LINE_REGEX
from .mappings import *


HEADER_CONTENT = \
"""/**
 * @brief Defines key sequence for Linux systems.
 *
 * This particular set of key sequence was generated by rd_parser module.
 *
 * This source code serves as submission to my bachelor thesis topic
 * "Implement Rubber Duckies on Available USB Devices and Make a Practical Test"
 * at FIT, BUT 2022/23.
 *
 * @author Hung Do
 * @date 21/12/2022
 */
#include "key_seqv.h"

/// List of key sequences for (my) Linux system
struct key_seqv_t key_seqvs[] = {
    INITIAL_DELAY,
"""

FOOTER_CONTENT = \
"""    LAST_ITEM,
};
"""

class KeySeqvParser:

    def __init__(self, in_file: TextIO|TextIOWrapper=sys.stdin,
                 out_file: TextIO|TextIOWrapper=sys.stdout):
        self._in_file = in_file
        self._out_file = out_file
        self._lof_keyseqvs: list[KeySeqv] = []
        self._compile_patterns()


    @property
    def lof_keyseqvs(self) -> tuple:
        """Returns set of key sequences."""
        return tuple(self._lof_keyseqvs)


    def _compile_patterns(self):
        self._line_regex = re.compile(LINE_REGEX)
        self._key_seqv_regex = re.compile(KEY_SEQV_REGEX)


    def clear_lof_keyseqvs(self):
        """Clear the set of key sequences."""
        self._lof_keyseqvs.clear()


    def set_out_file(self, new_out_file: TextIO|TextIOWrapper):
        if new_out_file:
            self._out_file = new_out_file


    def set_in_file(self, new_in_file: TextIO|TextIOWrapper):
        if new_in_file:
            self._in_file = new_in_file


    def parse_line(self, line: str):

        def _get_new_sequence_structure(): # -> dict[str, list[Any]|int]:
            return {
                'delay': 0,
                'modifiers': [],
                'keys': []
            }

        ks_struct = _get_new_sequence_structure()

        matches = self._key_seqv_regex.findall(line)
        print(matches)
        for seqv in matches:
            # load delay
            if seqv[Groups.DELAY_ORIGINAL.value]:
                if ks_struct['keys'] or ks_struct['delay']:
                    self._lof_keyseqvs.append(KeySeqv(**ks_struct))
                    ks_struct = _get_new_sequence_structure()
                ks_struct['delay'] = int(seqv[Groups.DELAY_VALUE.value])

                # TODO: create delay
                pass
            # load special
            elif seqv[Groups.SPECIAL_ORIGINAL.value]:
                # TODO: modifiers/special
                pass
            # load normal keys
            else:
                value: str = seqv[Groups.NORMAL_KEYS.value]
                # check if symbol needs shift modifier
                if value in shift_mapping or value.isupper():
                    if ks_struct['modifier']:
                        pass
                    pass
                else:
                    ks_struct['keys'].append(normal_mapping[value])
                if len(ks_struct['keys']) > 5:
                    self._lof_keyseqvs.append(KeySeqv(**ks_struct))
                    ks_struct = _get_new_sequence_structure()
                # normal keys
            # get max 6 keys
            # create KeySeqv instance
            # insert it in self._lof_keyseqvs
        if ks_struct['keys']:
            self._lof_keyseqvs.append(KeySeqv(**ks_struct))
        if self._lof_keyseqvs:
            last_item = self._lof_keyseqvs[-1]
            last_item.last = True


    def parse_content(self):
        """Parse the input file."""

        for i, line in enumerate(self._in_file):
            # line check
            if not self._line_regex.match(line):
                logging.warn(f'Unexpected character in line {i+1}')
                pass

            # parsing
            self.parse_line(line)


    def generate_output_file(self):
        # generate header
        self._out_file.write(HEADER_CONTENT)
        # generate content
        for ks in self._lof_keyseqvs:
            self._out_file.write(str(ks))
        # generate footer
        self._out_file.write(FOOTER_CONTENT)
